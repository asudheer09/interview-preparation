collection ---> Interface
If we want to represent group of objects as a single entity.
example : basket contains different fruits, each fruit is object.

Collection is the root interface.
It has 3 child interfaces
1.List
2.Set
3.Queue

1.List
------
1. List is the child interface of the collection.
2. Insertion order is preserved.
3. duplicates are allowed.
4. heterogeneous objects are allowed.
5. implementation classes are : ArrayList,LinkedList,Vector,Stack.

1. ArrayList:
=============
1. default size of ArrayList is 10.
2. ArrayList is one of the implementation class of List interface.
3. internal datastructures is dynamic array.
4. insertion order is preserved.
5. duplicates are allowed.
6. Heterogeneous objects are allowed.
7. If our frequent operation is retrieval then we use ArrayList.

List<String> list= new ArrayList<>();

2. Vector

1. Vector is a legacy class.
2. internal datastructures is dynamic array.
3. All methods in vector are synchronized.
4. insertion order is preserved.
5. duplicates are allowed.
6. Heterogeneous objects are allowed.

ArrayList vs Vector

https://www.javatpoint.com/difference-between-arraylist-and-vector

LinkedList:
0. LinkedList is one of the implementation class of List interface.
1. Insertion order is preserved.
2. duplicates are allowed.
3. heterogeneous objects are allowed.
4. internal data structure is double linked list.
5. If our frequent operation is insertion or deletion then we use LinkedList.

Difference between LinkedList vs ArrayList:

Linked List :
internal data structure is double linked list.
if our frequent operation is insertion or deletion then we use LinkedList.

ArrayList:
internal data structure is dynamic array or re-sizable array.
if our frequent operation is retrieval then we use arraylist.

2. Set
1. Set is the child interface of the collection.
2. Insertion order is not preserved.
3. duplicates are not allowed.
4. heterogeneous objects are allowed.
5. Implementation classes are : HashSet, LinkedHashSet, TreeSet.

HashSet:
1. it is the implementation class of Set interface.
2. internal data structure is Hashtable.
3. insertion order is not preserved.
4. duplicates are not allowed.
5. null insertion is possible only once.
6. HashSet introduced in 1.2v
7. heterogeneous objects are allowed.

LinkedHashSet:
1. it is the implementation class of Set interface.
2. insertion order is preserved.
3. internal data structure is LinkedList+ Hashtable.
4. introduced in jdk 1.4 version.
5. heterogeneous objects are allowed.


TreeSet:
1. it is the implementation of Set interface.
2. internal data structure is balanced tree.
3. only homogeneous objects are allowed.
4. null insertion is possible for empty TreeSet.
5. when you add null to the non-empty TreeSet will give null pointer exception.
6. TreeSet will sort the object based on default natural sorting order.

Map:
If we want to store the data in the form of key-value pair then we should use Map.
Map is different from Collection, Map is used to store data in the form of key-value pair where as Collection is used
to store group of objects as single entity.
Each key-value pair is called entry.

Map has the following implementation classes :
HashMap, LinkedHashMap and TreeMap.

HashMap:
1. HashMap is one of the implementation class of Map interface.
2. It is used to store data in the form of key-value pair.
3. key always should unique( duplicates are not allowed in the keys)
4. But values can be duplicated.
5. One null key is allowed and multiple null values are allowed.
6. Internal data structure of HashMap is HashTable.

    public V put(K var1, V var2) {
        return this.putVal(hash(var1), var1, var2, false, true);
    }

How HashMap internally works?

    HashMap<String, Integer> map = new HashMap<>();
    map.put("Aman", 19);  ---> internally it will call hash(key) then it will return index value. 1
    map.put("Sunny", 29);  ---> internally it will call hash(key) then it will return index value. 5
    map.put("Ritesh", 39);   ---> internally it will call hash(key) then it will return index value 1

    0--->
    1---> "Aman", 19--> "Ritesh", 39
    2--->
    3--->
    4---> "Sunny", 29

    map.get(key)---> map.get("Ritesh")---> internally it will call hash(key) then it will return index value 1



3. Queue
1. it is the child interface of collection
2. if you want to process the objects based on priority then we will go Queue.

String vs StringBuffer vs StringBuilder

String immutable
( once we create an object we cant change, if we try to change it will create new object)

StringBuffer and StringBuilder mutable.

StringBuffer is thread safe and StringBuilder is not thread safe.

performance point of view StringBuilder is faster than StringBuffer.

final vs finally vs finalize()

final is a keyword, applicable for methods, classes and variables

final class     ---> we cant extend this class.
final variable  ---> we cant change its value once it is assigned.
final method    ---> we cant override that method in the child class.

finally ---> it is a block used in exception handling along with try or try-catch block.

try{

} finally{

}

try {
// risky code
}catch(Exception e){
// to catch exception
}finally{
// resource closing logic
}

finally block always executed whether exception is occurred or not.
only way to stop executing the finally block is writing System.exit(0);
inside finally block we can close the resources or connection closing etc.

finalize() method:

Just before object is garbage collected this finalize() method will be called on that object.

what is garbage collection?
removing un-used or un-referenced objects from the heap memory.

what is immutable class and how to create ?

Immutable means once we create any object and try to modify it, instead of modification it
creates new object.

Example : String , Integer,Float, Long, Character etc.

String s= "hello";

s=s+" world"; // hello world

How to create Immutable class :
1. declare the class as final.
2. declare all the variable as final.
3. provides only getters, no-setters.
4. create constructor to initialize the object.

What is singleton and how to create Singleton?

Singleton means only one object will be created and that object should be re-used.

Use case : while connecting with jdbc we will use this.

How to create singleton?

1. create a class.
2. declare static variable of the same class.
3. create private constructor.
3. define a static factory method that returns same class object.
4. call the static factory method to get the instance of the class.















